/*!
 * maptalks.wind v0.1.4
 * LICENSE : UNLICENSED
 * (c) 2016-2019 maptalks.org
 */
!function(n,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("maptalks"),require("@maptalks/gl")):"function"==typeof define&&define.amd?define(["exports","maptalks","@maptalks/gl"],t):t((n=n||self).maptalks=n.maptalks||{},n.maptalks,n.maptalksgl)}(this,function(n,_,l){"use strict";function i(n,t){n.prototype=Object.create(t.prototype),(n.prototype.constructor=n).__proto__=t}var r="precision mediump float;\n\n\n\nattribute vec2 a_pos;\n\n\n\nvarying vec2 v_tex_pos;\n\n\n\nvoid main() {\n\n    v_tex_pos = a_pos;\n\n    gl_Position = vec4(1.0 - 2.0 * a_pos, 0, 1);\n\n}\n\n",t=function(e){function n(n){var t;return(t=e.call(this,n)||this).n(),t.t={},t}i(n,e);var t=n.prototype;return t.draw=function(){this.prepareCanvas(),this.i()},t.drawOnInteracting=function(){this.i()},t.needToRedraw=function(){return!0},t.hitDetect=function(){return!1},t.createContext=function(){if(this.canvas.gl&&this.canvas.gl.wrap)this.gl=this.canvas.gl.wrap();else{var n=this.layer.options.glOptions||{alpha:!0,depth:!0,stencil:!0};this.glOptions=n,this.gl=this.gl||this.e(this.canvas,n)}this.regl=l.createREGL({gl:this.gl,extensions:["OES_element_index_uint","OES_standard_derivatives"],optionalExtensions:this.layer.options.glExtensions||[]}),this.r()},t.clearCanvas=function(){this.canvas&&(this.regl.clear({color:[0,0,0,0],depth:1,stencil:0}),e.prototype.clearCanvas.call(this))},t.n=function(){this.o=this.layer.options.count,this.s=this.layer.options.fadeOpacity,this.a=this.layer.options.speedFactor,this._=this.layer.options.dropRate,this.l=this.layer.options.dropRateBump,this.c=this.layer.options.colors},t.r=function(){this.renderer=new l.reshader.Renderer(this.regl);var n=this.canvas.width||1,t=this.canvas.height||1;this.h=n,this.p=t,this.u(),this.f(),this.v(),this.setColorRamp(this.c),this.d=this.regl.framebuffer({color:this.regl.texture({width:n,height:t,wrap:"clamp"}),depth:!0})},t.f=function(){var n=this.canvas.width||1,t=this.canvas.height||1,i=new Uint8Array(n*t*4);this.m=this.regl.texture({width:n,height:t,data:i}),this.w=this.regl.texture({width:n,height:t,data:i}),this.g||this.b()},t.b=function(){var i=this;if(_.Util.isString(this.t)&&-1<this.t.indexOf(".json"))_.Ajax.get(this.t,function(n,t){if(n)throw new Error(n);i.t=i.U(JSON.parse(t)),i.M()});else if(this.isGFSObject())this.t=this.U(this.t),this.M();else if(_.Util.isString(this.t.image)){var n=new Image;n.src=this.t.image,n.onload=function(){i.t.image=n,i.M(),i.layer.fire("windtexture-create-debug")}}else this.M()},t.M=function(){this.t&&(this.g=this.regl.texture({width:this.t.width,height:this.t.height,data:this.t.image,mag:"linear",min:"linear"}))},t.isGFSObject=function(){return!(!this.t[0]||!this.t[0].header||"object"!=typeof this.t[0].header)},t.u=function(){var n=this.D=Math.ceil(Math.sqrt(this.o));this.k=n*n;for(var t=new Uint8Array(4*this.k),i=0;i<t.length;i++)t[i]=Math.floor(256*Math.random());if(this.regl){this.V=this.regl.texture({data:t,width:n,height:n}),this.z=this.regl.texture({data:t,width:n,height:n}),this.C=new Float32Array(this.k);for(var e=0;e<this.k;e++)this.C[e]=e}},t.v=function(){var n=this,t={x:0,y:0,width:function(){return n.canvas?n.canvas.width:1},height:function(){return n.canvas?n.canvas.height:1}};this.drawShader=new l.reshader.MeshShader({vert:"precision mediump float;\n\n\n\nattribute float a_index;\n\n\n\nuniform sampler2D u_particles;\n\nuniform float u_particles_res;\n\n\n\nvarying vec2 v_particle_pos;\n\n\n\nvoid main() {\n\n    vec4 color = texture2D(u_particles, vec2(\n\n        fract(a_index / u_particles_res),\n\n        floor(a_index / u_particles_res) / u_particles_res));\n\n\n\n    // decode current particle position from the pixel's RGBA value\n\n    v_particle_pos = vec2(\n\n        color.r / 255.0 + color.b,\n\n        color.g / 255.0 + color.a);\n\n\n\n    gl_PointSize = 1.0;\n\n    gl_Position = vec4(2.0 * v_particle_pos.x - 1.0, 1.0 - 2.0 * v_particle_pos.y, 0, 1);\n\n}\n\n",frag:"precision mediump float;\n\n\n\nuniform sampler2D u_wind;\n\nuniform vec2 u_wind_min;\n\nuniform vec2 u_wind_max;\n\nuniform sampler2D u_color_ramp;\n\n\n\nvarying vec2 v_particle_pos;\n\nuniform vec4 extent;\n\n\n\nuniform vec4 full_extent;\n\nuniform float full_width;\n\nuniform float full_height;\n\nuniform float dx;\n\nuniform float dy;\n\n\n\n//重新计算视图区域的纹理采样坐标，将粒子缩放到extent范围内\n\nvec2 computeUV(vec2 v_particle_pos) {\n\n    // float xmin = (extent.x - full_extent.x) / (full_width * dx);\n\n    // float ymin = (extent.z - full_extent.z) / (full_height * dy);\n\n    // float xmax = (extent.y - full_extent.x) / (full_width * dx);\n\n    // float ymax = (extent.w - full_extent.z) / (full_height * dy);\n\n    float xmin = (extent.x - (-180.0)) / (360.0 * 1.0);\n\n    float ymin = (extent.z - (-90.0)) / (180.0 * 1.0);\n\n    float xmax = (extent.y - (-180.0)) / (360.0 * 1.0);\n\n    float ymax = (extent.w - (-90.0)) / (180.0 * 1.0);\n\n    float xWidth = xmax - xmin;\n\n    float yHeight = ymax - ymin;\n\n    vec2 centerUv = vec2(0.5, 0.5);\n\n\n\n    if(v_particle_pos.x < centerUv.x && v_particle_pos.y < centerUv.y) {\n\n        v_particle_pos.x = v_particle_pos.x * xWidth + xmin;\n\n        v_particle_pos.y = v_particle_pos.y * yHeight + ymin;\n\n    } else if(v_particle_pos.x < centerUv.x && v_particle_pos.y > centerUv.y) {\n\n        v_particle_pos.x = v_particle_pos.x * xWidth + xmin;\n\n        v_particle_pos.y = (v_particle_pos.y - 1.0) * yHeight + ymax ;\n\n    } else if(v_particle_pos.x > centerUv.x && v_particle_pos.y < centerUv.y) {\n\n        v_particle_pos.x = (v_particle_pos.x - 1.0) * xWidth + xmax;\n\n        v_particle_pos.y = v_particle_pos.y * yHeight + ymin;\n\n    } else if(v_particle_pos.x > centerUv.x && v_particle_pos.y > centerUv.y) {\n\n        v_particle_pos.x = (v_particle_pos.x - 1.0) * xWidth + xmax;\n\n        v_particle_pos.y = (v_particle_pos.y - 1.0) * yHeight + ymax;\n\n    }\n\n    if (v_particle_pos.x > 1.0) {\n\n        v_particle_pos.x = v_particle_pos.x - 1.0;\n\n    } else if(v_particle_pos.x < 0.0) {\n\n        v_particle_pos.x = v_particle_pos.x + 1.0;\n\n    }\n\n    return v_particle_pos;\n\n}\n\n\n\nvoid main() {\n\n    vec2 particle_pos = computeUV(v_particle_pos);\n\n    if (particle_pos.y < 0.0 || particle_pos.y > 1.0) {\n\n        gl_FragColor = vec4(0.0);\n\n    } else {\n\n        vec2 velocity = mix(u_wind_min, u_wind_max, texture2D(u_wind, particle_pos).rg);\n\n        float speed_t = length(velocity) / length(u_wind_max);\n\n    \n\n        // color ramp is encoded in a 16x16 texture\n\n        vec2 ramp_pos = vec2(\n\n            fract(16.0 * speed_t),\n\n            floor(16.0 * speed_t) / 16.0);\n\n    \n\n        gl_FragColor = texture2D(u_color_ramp, ramp_pos);\n\n    }\n\n}\n\n",uniforms:["extent","u_wind","u_particles","u_color_ramp","u_particles_res","u_wind_min","u_wind_max","full_width","full_height","full_extent","dx","dy"],extraCommandProps:{viewport:t},defines:{}}),this.screenShader=new l.reshader.MeshShader({vert:r,frag:"precision mediump float;\n\n\n\nuniform sampler2D u_screen;\n\nuniform float u_opacity;\n\n\n\nvarying vec2 v_tex_pos;\n\n\n\nvoid main() {\n\n    vec4 color = texture2D(u_screen, 1.0 - v_tex_pos);\n\n    // a hack to guarantee opacity fade out even with a value close to 1.0\n\n    gl_FragColor = vec4(floor(255.0 * color * u_opacity) / 255.0);\n\n}\n\n",uniforms:["u_screen","u_opacity"],extraCommandProps:{viewport:t},defines:{}}),this.updateSHader=new l.reshader.MeshShader({vert:r,frag:"precision highp float;\n\n\n\nuniform sampler2D u_particles;\n\nuniform sampler2D u_wind;\n\nuniform vec2 u_wind_res;\n\nuniform vec2 u_wind_min;\n\nuniform vec2 u_wind_max;\n\nuniform float u_rand_seed;\n\nuniform float u_speed_factor;\n\nuniform float u_drop_rate;\n\nuniform float u_drop_rate_bump;\n\nuniform vec4 full_extent;\n\nuniform float full_width;\n\nuniform float full_height;\n\n\n\nvarying vec2 v_tex_pos;\n\n\n\nuniform vec4 extent;\n\nuniform float dx;\n\nuniform float dy;\n\n\n\n// pseudo-random generator\n\nconst vec3 rand_constants = vec3(12.9898, 78.233, 4375.85453);\n\nfloat rand(const vec2 co) {\n\n    float t = dot(rand_constants.xy, co);\n\n    return fract(sin(t) * (rand_constants.z + t));\n\n}\n\n\n\nvec2 getNewUV(vec2 uv) {\n\n    // float xmin = (extent.x - full_extent.x) / (full_width * dx);\n\n    // float ymin = (extent.z - full_extent.z) / (full_height * dy);\n\n    // float xmax = (extent.y - full_extent.x) / (full_width * dx);\n\n    // float ymax = (extent.w - full_extent.z) / (full_height * dy);\n\n    float xmin = (extent.x - (-180.0)) / (360.0);\n\n    float ymin = (extent.z - (-90.0)) / (180.0);\n\n    float xmax = (extent.y - (-180.0)) / (360.0);\n\n    float ymax = (extent.w - (-90.0)) / (180.0);\n\n    float xWidth = xmax - xmin;\n\n    float yHeight = ymax - ymin;\n\n    vec2 centerUv = vec2(0.5, 0.5);\n\n    vec2 v_particle_pos = uv;\n\n\n\n    if(v_particle_pos.x < centerUv.x && v_particle_pos.y < centerUv.y) {\n\n        v_particle_pos.x = v_particle_pos.x * xWidth + xmin;\n\n        v_particle_pos.y = v_particle_pos.y * yHeight + ymin;\n\n    } else if(v_particle_pos.x < centerUv.x && v_particle_pos.y > centerUv.y) {\n\n        v_particle_pos.x = v_particle_pos.x * xWidth + xmin;\n\n        v_particle_pos.y = (v_particle_pos.y - 1.0) * yHeight + ymax ;\n\n    } else if(v_particle_pos.x > centerUv.x && v_particle_pos.y < centerUv.y) {\n\n        v_particle_pos.x = (v_particle_pos.x -  1.0) * xWidth + xmax;\n\n        v_particle_pos.y = v_particle_pos.y * yHeight + ymin;\n\n    } else if(v_particle_pos.x > centerUv.x && v_particle_pos.y > centerUv.y) {\n\n        v_particle_pos.x = (v_particle_pos.x -  1.0) * xWidth + xmax;\n\n        v_particle_pos.y = (v_particle_pos.y -  1.0) * yHeight + ymax;\n\n    }\n\n    if (v_particle_pos.x > 1.0) {\n\n        v_particle_pos.x = v_particle_pos.x - 1.0;\n\n    } else if(v_particle_pos.x < 0.0) {\n\n        v_particle_pos.x = v_particle_pos.x + 1.0;\n\n    }\n\n    return v_particle_pos;\n\n}\n\n\n\n// wind speed lookup; use manual bilinear filtering based on 4 adjacent pixels for smooth interpolation\n\nvec2 lookup_wind(const vec2 uv) {\n\n    // return texture2D(u_wind, uv).rg; // lower-res hardware filtering\n\n    vec2 px = 1.0 / u_wind_res;\n\n    // vec2 vc = (floor(uv * u_wind_res)) * px;\n\n    // vec2 f = fract(uv * u_wind_res);\n\n    vec2 vc = (floor(uv * u_wind_res)) * px;\n\n    vec2 f = fract(uv * u_wind_res);\n\n    vec2 tl = texture2D(u_wind, vc).rg;\n\n    vec2 tr = texture2D(u_wind, vc + vec2(px.x, 0)).rg;\n\n    vec2 bl = texture2D(u_wind, vc + vec2(0, px.y)).rg;\n\n    vec2 br = texture2D(u_wind, vc + px).rg;\n\n    return mix(mix(tl, tr, f.x), mix(bl, br, f.x), f.y);\n\n}\n\n\n\nvoid main() {\n\n    vec4 color = texture2D(u_particles, v_tex_pos);\n\n    vec2 pos = vec2(\n\n        color.r / 255.0 + color.b,\n\n        color.g / 255.0 + color.a); // decode particle position from pixel RGBA\n\n    vec2 newUV = getNewUV(pos);\n\n    if (newUV.y < 0.0 || newUV.y > 1.0) {\n\n        gl_FragColor = vec4(0.0);\n\n    } else {\n\n        vec2 velocity = mix(u_wind_min, u_wind_max, lookup_wind(newUV));\n\n        float speed_t = length(velocity) / length(u_wind_max);\n\n    \n\n        // take EPSG:4236 distortion into account for calculating where the particle moved\n\n        float distortion = cos(radians(newUV.y));\n\n        vec2 offset = vec2(velocity.x / distortion, -velocity.y) * 0.0001 * u_speed_factor;\n\n    \n\n        // update particle position, wrapping around the date line\n\n        pos = fract(1.0 + pos + offset);\n\n    \n\n        // a random seed to use for the particle drop\n\n        vec2 seed = (pos + v_tex_pos) * u_rand_seed;\n\n    \n\n        // drop rate is a chance a particle will restart at random position, to avoid degeneration\n\n        float drop_rate = u_drop_rate + speed_t * u_drop_rate_bump;\n\n        float drop = step(1.0 - drop_rate, rand(seed));\n\n    \n\n        vec2 random_pos = vec2(\n\n            rand(seed + 1.3),\n\n            rand(seed + 2.1));\n\n        pos = mix(pos, random_pos, drop);\n\n    \n\n        // encode the new particle position back into RGBA\n\n        gl_FragColor = vec4(\n\n            fract(pos * 255.0),\n\n            floor(pos * 255.0) / 255.0);\n\n    }\n\n}\n\n",uniforms:["extent","u_wind","u_particles","u_rand_seed","u_wind_res","u_wind_min","u_wind_max","u_speed_factor","u_drop_rate","u_drop_rate_bump","full_width","full_height","full_extent","dx","dy"],extraCommandProps:{viewport:{x:0,y:0,width:function(){return n.D},height:function(){return n.D}},dither:!0},defines:{}}),this.windShader=new l.reshader.MeshShader({vert:"precision mediump float;\n\n\n\nattribute vec3 a_pos;\n\nuniform mat4 projViewModelMatrix;\n\nattribute vec2 uv;\n\nvarying vec2 v_tex_pos;\n\n\n\nvoid main() {\n\n    v_tex_pos = uv;\n\n    gl_Position = projViewModelMatrix * vec4(a_pos, 1.0);\n\n}\n\n",frag:"precision mediump float;\n\nuniform sampler2D u_screen;\n\nuniform float u_opacity;\n\n\n\nvarying vec2 v_tex_pos;\n\n\n\nvoid main() {\n\n    vec4 color = texture2D(u_screen, v_tex_pos);\n\n    // a hack to guarantee opacity fade out even with a value close to 1.0\n\n    gl_FragColor = vec4(floor(255.0 * color * u_opacity) / 255.0);\n\n}\n\n",uniforms:["u_screen","u_opacity","projViewMatrix",{name:"projViewModelMatrix",type:"function",fn:function(n,t){return l.mat4.multiply([],t.projViewMatrix,t.modelMatrix)}}],extraCommandProps:{viewport:t},defines:{}})},t.U=function(n){for(var t=n[0],i=n[1],e=Math.min.apply(null,t.data),r=Math.max.apply(null,t.data),o=Math.min.apply(null,i.data),s=Math.max.apply(null,i.data),a=[],_=0;_<t.data.length;_++){var l=Math.floor(255*(t.data[_]-e)/(r-e));a.push(l);var c=Math.floor(255*(i.data[_]-o)/(s-o));a.push(c),a.push(0),a.push(255)}return{width:t.header.nx,height:t.header.ny,uMin:e,uMax:r,vMin:o,vMax:s,image:a,full_extent:[t.header.lo1,t.header.lo2,t.header.la1,t.header.la2],dx:t.header.dx,dy:t.header.dy}},t.e=function(n,t){for(var i=["webgl","experimental-webgl"],e=null,r=0;r<i.length;++r){try{e=n.getContext(i[r],t)}catch(n){}if(e)break}return e},t.resizeCanvas=function(){if(this.m&&this.w&&this.j()){var n=this.canvas.width,t=this.canvas.height,i=new Uint8Array(n*t*4);this.m({width:n,height:t,data:i}),this.w({width:n,height:t,data:i}),this.h=n,this.p=t}e.prototype.resizeCanvas.call(this)},t.j=function(){return this.h!=this.canvas.width||this.p!=this.canvas.height},t.setData=function(n){this.t=n,this.regl&&this.b()},t.setParticlesCount=function(n){this.o=n,this.u()},t.getParticlesCount=function(){return this.o},t.setColorRamp=function(n){this.A=this.regl.texture({width:16,height:16,data:this.P(n),mag:"linear",min:"linear"})},t.P=function(n){var t=document.createElement("canvas"),i=t.getContext("2d");t.width=256,t.height=1;var e=i.createLinearGradient(0,0,256,0);for(var r in n)e.addColorStop(+r,n[r]);return i.fillStyle=e,i.fillRect(0,0,256,1),new Uint8Array(i.getImageData(0,0,256,1).data)},t.W=function(){var n=new l.reshader.Geometry({a_pos:[0,0,1,0,0,1,0,1,1,0,1,1]},6,0,{primitive:"triangle",positionAttribute:"a_pos",positionSize:2}),t=new l.reshader.Mesh(n);return new l.reshader.Scene([t])},t.H=function(){var n=new l.reshader.Geometry({a_index:this.C},this.C.length,0,{primitive:"point",positionAttribute:"a_index",positionSize:1}),t=new l.reshader.Mesh(n);return new l.reshader.Scene([t])},t.S=function(){var n=this.layer.getMap(),t=this.F(),i=c(n,new _.Coordinate([t.xmin,t.ymax])),e=c(n,new _.Coordinate(t.xmin,t.ymin)),r=c(n,new _.Coordinate(t.xmax,t.ymin)),o=c(n,new _.Coordinate(t.xmax,t.ymax)),s=new l.reshader.Geometry({a_pos:[e[0],e[1],e[2],r[0],r[1],r[2],i[0],i[1],i[2],i[0],i[1],i[2],r[0],r[1],r[2],o[0],o[1],o[2]],uv:[0,0,1,0,0,1,0,1,1,0,1,1]},6,0,{primitive:"triangle",positionAttribute:"a_pos",positionSize:3}),a=new l.reshader.Mesh(s);return new l.reshader.Scene([a])},t.O=function(){var n=this.layer.getMap();this.d({color:this.w}),this.R();var t=this.W();this.renderer.render(this.screenShader,{u_screen:this.m,u_opacity:this.s},t,this.d);var i=this.S();this.renderer.render(this.windShader,{u_screen:this.w,u_opacity:1,projViewMatrix:n.projViewMatrix},i);var e=this.m;this.m=this.w,this.w=e},t.R=function(){var n=this.F(),t=this.H();this.renderer.render(this.drawShader,{extent:[n.xmin,n.xmax,-n.ymax,-n.ymin],u_wind:this.g,u_particles:this.V,u_color_ramp:this.A,u_particles_res:this.D,u_wind_min:[this.t.uMin,this.t.vMin],u_wind_max:[this.t.uMax,this.t.vMax],full_width:this.t.width,full_height:this.t.height,full_extent:this.t.full_extent,dx:this.t.dx,dy:this.t.dy},t,this.d)},t.B=function(){this.d({color:this.z});var n=this.F(),t=this.W();this.renderer.render(this.updateSHader,{extent:[n.xmin,n.xmax,-n.ymax,-n.ymin],u_wind:this.g,u_particles:this.V,u_rand_seed:Math.random(),u_wind_res:[this.t.width,this.t.height],u_wind_min:[this.t.uMin,this.t.vMin],u_wind_max:[this.t.uMax,this.t.vMax],u_speed_factor:this.a,u_drop_rate:this._,u_drop_rate_bump:this.l,full_width:this.t.width,full_height:this.t.height,full_extent:this.t.full_extent,dx:this.t.dx,dy:this.t.dy},t,this.d);var i=this.V;this.V=this.z,this.z=i},t.i=function(){this.w&&this.m&&this.g&&(this.n(),this.O(),this.B())},t.F=function(){var n=this.layer.getMap().getExtent();return n.xmax<n.xmin&&(n.xmax=n.xmax+360),n.xmin=n.xmin<this.t.full_extent[0]?this.t.full_extent[0]:n.xmin,n.xmax=n.xmax>this.t.full_extent[1]?this.t.full_extent[1]:n.xmax,n.ymin=n.ymin<this.t.full_extent[2]?this.t.full_extent[2]:n.ymin,n.ymax=n.ymax>this.t.full_extent[3]?this.t.full_extent[3]:n.ymax,n},t.getSpeed=function(n){if(this.regl&&this.t&&this.t.width){var t=(n.x%180+180)/360*this.t.width;if(n.y<-90||90<n.y)throw new Error("Invalid y for coordinate");var i=(90-n.y)/180*this.t.height,e=this.regl.framebuffer({color:this.g,width:this.t.width,height:this.t.height}),r=this.regl.read({x:t,y:i,width:1,height:1,framebuffer:e});return[r[0]*(this.t.uMax-this.t.uMin)/255+this.t.uMin,r[1]*(this.t.vMax-this.t.vMin)/255+this.t.vMin]}},n}(_.renderer.CanvasRenderer);function c(n,t,i){if(void 0===i&&(i=0),!n)return null;var e=n.coordinateToPoint(t,n.getGLZoom());return[e.x,e.y,i]}var e={renderer:"gl",count:65536,fadeOpacity:.996,speedFactor:.25,dropRate:.003,dropRateBump:.01,colors:{0:"#3288bd",.1:"#66c2a5",.2:"#abdda4",.3:"#e6f598",.4:"#fee08b",.5:"#fdae61",.6:"#f46d43",1:"#d53e4f"}},o=function(e){function n(n,t){var i;return(i=e.call(this,n,t)||this).options.data&&i.setWind(t.data),i}i(n,e);var t=n.prototype;return t.setWind=function(n){this.G("setData",n)},t.setParticlesCount=function(n){this.G("setParticlesCount",n)},t.getParticlesCount=function(){return this.G("getParticlesCount")},t.setRampColors=function(n){this.G("setColorRamp",n)},t.getWindSpeed=function(n){return this.G("getSpeed",n)},t.G=function(t,i){var n=this.getRenderer();if(n)return n[t](i);this.on("renderercreate",function(n){return n.renderer[t](i)})},n}(_.Layer);o.mergeOptions(e),o.registerJSONType("WindLayer"),o.registerRenderer("gl",t),n.WindLayer=o,Object.defineProperty(n,"q",{value:!0}),"undefined"!=typeof console&&console.log("maptalks.wind v0.1.4, requires maptalks@<2.0.0.")});

/*!
 * maptalks.wind v0.1.1
 * LICENSE : UNLICENSED
 * (c) 2016-2019 maptalks.org
 */
import{renderer as n,Util as t,Coordinate as e,Layer as i}from"maptalks";import{createREGL as r,reshader as s,mat4 as o}from"@maptalks/gl";var a="precision mediump float;\n\n\n\nattribute float a_index;\n\n\n\nuniform sampler2D u_particles;\n\nuniform float u_particles_res;\n\n\n\nvarying vec2 v_particle_pos;\n\n\n\nvoid main() {\n\n    vec4 color = texture2D(u_particles, vec2(\n\n        fract(a_index / u_particles_res),\n\n        floor(a_index / u_particles_res) / u_particles_res));\n\n\n\n    // decode current particle position from the pixel's RGBA value\n\n    v_particle_pos = vec2(\n\n        color.r / 255.0 + color.b,\n\n        color.g / 255.0 + color.a);\n\n\n\n    gl_PointSize = 1.0;\n\n    gl_Position = vec4(2.0 * v_particle_pos.x - 1.0, 1.0 - 2.0 * v_particle_pos.y, 0, 1);\n\n}\n\n",_="precision mediump float;\n\n\n\nuniform sampler2D u_wind;\n\nuniform vec2 u_wind_min;\n\nuniform vec2 u_wind_max;\n\nuniform sampler2D u_color_ramp;\n\n\n\nvarying vec2 v_particle_pos;\n\nuniform vec4 extent;\n\n\n\n//重新计算视图区域的纹理采样坐标，将粒子缩放到extent范围内\n\nvec2 computeUV(vec2 v_particle_pos) {\n\n    float xmin = (extent.x + 180.0) / 360.0;\n\n    float ymin = (extent.z + 90.0) / 180.0;\n\n    float xmax = (extent.y + 180.0) / 360.0;\n\n    float ymax = (extent.w + 90.0) / 180.0;\n\n    float xWidth = xmax - xmin;\n\n    float yHeight = ymax - ymin;\n\n    vec2 centerUv = vec2(0.5, 0.5);\n\n\n\n    if(v_particle_pos.x < centerUv.x && v_particle_pos.y < centerUv.y) {\n\n        v_particle_pos.x = v_particle_pos.x * xWidth + xmin;\n\n        v_particle_pos.y = v_particle_pos.y * yHeight + ymin;\n\n    } else if(v_particle_pos.x < centerUv.x && v_particle_pos.y > centerUv.y) {\n\n        v_particle_pos.x = v_particle_pos.x * xWidth + xmin;\n\n        v_particle_pos.y = (v_particle_pos.y - 1.0) * yHeight + ymax ;\n\n    } else if(v_particle_pos.x > centerUv.x && v_particle_pos.y < centerUv.y) {\n\n        v_particle_pos.x = (v_particle_pos.x - 1.0) * xWidth + xmax;\n\n        v_particle_pos.y = v_particle_pos.y * yHeight + ymin;\n\n    } else if(v_particle_pos.x > centerUv.x && v_particle_pos.y > centerUv.y) {\n\n        v_particle_pos.x = (v_particle_pos.x - 1.0) * xWidth + xmax;\n\n        v_particle_pos.y = (v_particle_pos.y - 1.0) * yHeight + ymax;\n\n    }\n\n    if (v_particle_pos.x > 1.0) {\n\n        v_particle_pos.x = v_particle_pos.x - 1.0;\n\n    } else if(v_particle_pos.x < 0.0) {\n\n        v_particle_pos.x = v_particle_pos.x + 1.0;\n\n    }\n\n    return v_particle_pos;\n\n}\n\n\n\nvoid main() {\n\n    vec2 particle_pos = computeUV(v_particle_pos);\n\n    if (particle_pos.y < 0.0 || particle_pos.y > 1.0) {\n\n        gl_FragColor = vec4(0.0);\n\n    } else {\n\n        vec2 velocity = mix(u_wind_min, u_wind_max, texture2D(u_wind, particle_pos).rg);\n\n        float speed_t = length(velocity) / length(u_wind_max);\n\n    \n\n        // color ramp is encoded in a 16x16 texture\n\n        vec2 ramp_pos = vec2(\n\n            fract(16.0 * speed_t),\n\n            floor(16.0 * speed_t) / 16.0);\n\n    \n\n        gl_FragColor = texture2D(u_color_ramp, ramp_pos);\n\n    }\n\n}\n\n",p="precision mediump float;\n\n\n\nattribute vec2 a_pos;\n\n\n\nvarying vec2 v_tex_pos;\n\n\n\nvoid main() {\n\n    v_tex_pos = a_pos;\n\n    gl_Position = vec4(1.0 - 2.0 * a_pos, 0, 1);\n\n}\n\n",c="precision mediump float;\n\n\n\nuniform sampler2D u_screen;\n\nuniform float u_opacity;\n\n\n\nvarying vec2 v_tex_pos;\n\n\n\nvoid main() {\n\n    vec4 color = texture2D(u_screen, 1.0 - v_tex_pos);\n\n    // a hack to guarantee opacity fade out even with a value close to 1.0\n\n    gl_FragColor = vec4(floor(255.0 * color * u_opacity) / 255.0);\n\n}\n\n",l="precision highp float;\n\n\n\nuniform sampler2D u_particles;\n\nuniform sampler2D u_wind;\n\nuniform vec2 u_wind_res;\n\nuniform vec2 u_wind_min;\n\nuniform vec2 u_wind_max;\n\nuniform float u_rand_seed;\n\nuniform float u_speed_factor;\n\nuniform float u_drop_rate;\n\nuniform float u_drop_rate_bump;\n\n\n\nvarying vec2 v_tex_pos;\n\n\n\nuniform vec4 extent;\n\n\n\n// pseudo-random generator\n\nconst vec3 rand_constants = vec3(12.9898, 78.233, 4375.85453);\n\nfloat rand(const vec2 co) {\n\n    float t = dot(rand_constants.xy, co);\n\n    return fract(sin(t) * (rand_constants.z + t));\n\n}\n\n\n\nvec2 getNewUV(vec2 uv) {\n\n    float xmin = (extent.x + 180.0) / 360.0;\n\n    float ymin = (extent.z + 90.0) / 180.0;\n\n    float xmax = (extent.y + 180.0) / 360.0;\n\n    float ymax = (extent.w + 90.0) / 180.0;\n\n    float xWidth = xmax - xmin;\n\n    float yHeight = ymax - ymin;\n\n    vec2 centerUv = vec2(0.5, 0.5);\n\n    vec2 v_particle_pos = uv;\n\n\n\n    if(v_particle_pos.x < centerUv.x && v_particle_pos.y < centerUv.y) {\n\n        v_particle_pos.x = v_particle_pos.x * xWidth + xmin;\n\n        v_particle_pos.y = v_particle_pos.y * yHeight + ymin;\n\n    } else if(v_particle_pos.x < centerUv.x && v_particle_pos.y > centerUv.y) {\n\n        v_particle_pos.x = v_particle_pos.x * xWidth + xmin;\n\n        v_particle_pos.y = (v_particle_pos.y - 1.0) * yHeight + ymax ;\n\n    } else if(v_particle_pos.x > centerUv.x && v_particle_pos.y < centerUv.y) {\n\n        v_particle_pos.x = (v_particle_pos.x -  1.0) * xWidth + xmax;\n\n        v_particle_pos.y = v_particle_pos.y * yHeight + ymin;\n\n    } else if(v_particle_pos.x > centerUv.x && v_particle_pos.y > centerUv.y) {\n\n        v_particle_pos.x = (v_particle_pos.x -  1.0) * xWidth + xmax;\n\n        v_particle_pos.y = (v_particle_pos.y -  1.0) * yHeight + ymax;\n\n    }\n\n    if (v_particle_pos.x > 1.0) {\n\n        v_particle_pos.x = v_particle_pos.x - 1.0;\n\n    } else if(v_particle_pos.x < 0.0) {\n\n        v_particle_pos.x = v_particle_pos.x + 1.0;\n\n    }\n\n    return v_particle_pos;\n\n}\n\n\n\n// wind speed lookup; use manual bilinear filtering based on 4 adjacent pixels for smooth interpolation\n\nvec2 lookup_wind(const vec2 uv) {\n\n    // return texture2D(u_wind, uv).rg; // lower-res hardware filtering\n\n    vec2 px = 1.0 / u_wind_res;\n\n    // vec2 vc = (floor(uv * u_wind_res)) * px;\n\n    // vec2 f = fract(uv * u_wind_res);\n\n    vec2 vc = (floor(uv * u_wind_res)) * px;\n\n    vec2 f = fract(uv * u_wind_res);\n\n    vec2 tl = texture2D(u_wind, vc).rg;\n\n    vec2 tr = texture2D(u_wind, vc + vec2(px.x, 0)).rg;\n\n    vec2 bl = texture2D(u_wind, vc + vec2(0, px.y)).rg;\n\n    vec2 br = texture2D(u_wind, vc + px).rg;\n\n    return mix(mix(tl, tr, f.x), mix(bl, br, f.x), f.y);\n\n}\n\n\n\nvoid main() {\n\n    vec4 color = texture2D(u_particles, v_tex_pos);\n\n    vec2 pos = vec2(\n\n        color.r / 255.0 + color.b,\n\n        color.g / 255.0 + color.a); // decode particle position from pixel RGBA\n\n    vec2 newUV = getNewUV(pos);\n\n    if (newUV.y < 0.0 || newUV.y > 1.0) {\n\n        gl_FragColor = vec4(0.0);\n\n    } else {\n\n        vec2 velocity = mix(u_wind_min, u_wind_max, lookup_wind(newUV));\n\n        float speed_t = length(velocity) / length(u_wind_max);\n\n    \n\n        // take EPSG:4236 distortion into account for calculating where the particle moved\n\n        float distortion = cos(radians(newUV.y * 180.0 - 90.0));\n\n        vec2 offset = vec2(velocity.x / distortion, -velocity.y) * 0.0001 * u_speed_factor;\n\n    \n\n        // update particle position, wrapping around the date line\n\n        pos = fract(1.0 + pos + offset);\n\n    \n\n        // a random seed to use for the particle drop\n\n        vec2 seed = (pos + v_tex_pos) * u_rand_seed;\n\n    \n\n        // drop rate is a chance a particle will restart at random position, to avoid degeneration\n\n        float drop_rate = u_drop_rate + speed_t * u_drop_rate_bump;\n\n        float drop = step(1.0 - drop_rate, rand(seed));\n\n    \n\n        vec2 random_pos = vec2(\n\n            rand(seed + 1.3),\n\n            rand(seed + 2.1));\n\n        pos = mix(pos, random_pos, drop);\n\n    \n\n        // encode the new particle position back into RGBA\n\n        gl_FragColor = vec4(\n\n            fract(pos * 255.0),\n\n            floor(pos * 255.0) / 255.0);\n\n    }\n\n}\n\n",h="precision mediump float;\n\n\n\nattribute vec3 a_pos;\n\nuniform mat4 projViewModelMatrix;\n\nattribute vec2 uv;\n\nvarying vec2 v_tex_pos;\n\n\n\nvoid main() {\n\n    v_tex_pos = uv;\n\n    gl_Position = projViewModelMatrix * vec4(a_pos, 1.0);\n\n}\n\n",v="precision mediump float;\n\nuniform sampler2D u_screen;\n\nuniform float u_opacity;\n\n\n\nvarying vec2 v_tex_pos;\n\n\n\nvoid main() {\n\n    vec4 color = texture2D(u_screen, v_tex_pos);\n\n    // a hack to guarantee opacity fade out even with a value close to 1.0\n\n    gl_FragColor = vec4(floor(255.0 * color * u_opacity) / 255.0);\n\n}\n\n";function u(n,t,e=0){if(!n)return null;const i=n.coordinateToPoint(t,n.getGLZoom());return[i.x,i.y,e]}const d={renderer:"gl",count:65536,fadeOpacity:.996,speedFactor:.25,dropRate:.003,dropRateBump:.01,colors:{0:"#3288bd",.1:"#66c2a5",.2:"#abdda4",.3:"#e6f598",.4:"#fee08b",.5:"#fdae61",.6:"#f46d43",1:"#d53e4f"}};class x extends i{constructor(n,t){super(n,t),this.options.data&&this.setWind(t.data)}setWind(n){this.t("setData",n)}setParticlesCount(n){this.t("setParticlesCount",n)}getParticlesCount(){return this.t("getParticlesCount")}setRampColors(n){this.t("setColorRamp",n)}getWindSpeed(n){return this.t("getSpeed",n)}t(n,t){const e=this.getRenderer();if(e)return e[n](t);this.on("renderercreate",e=>e.renderer[n](t))}}x.mergeOptions(d),x.registerJSONType("WindLayer"),x.registerRenderer("gl",class extends n.CanvasRenderer{constructor(n){super(n),this.i(),this.s={}}draw(){this.prepareCanvas(),this.o()}drawOnInteracting(){this.o()}needToRedraw(){return!0}hitDetect(){return!1}createContext(){if(this.canvas.gl&&this.canvas.gl.wrap)this.gl=this.canvas.gl.wrap();else{const n=this.layer.options.glOptions||{alpha:!0,depth:!0,stencil:!0};this.glOptions=n,this.gl=this.gl||this._(this.canvas,n)}this.regl=r({gl:this.gl,extensions:["OES_element_index_uint","OES_standard_derivatives"],optionalExtensions:this.layer.options.glExtensions||[]}),this.p()}clearCanvas(){this.canvas&&(this.regl.clear({color:[0,0,0,0],depth:1,stencil:0}),super.clearCanvas())}i(){this.l=this.layer.options.count,this.h=this.layer.options.fadeOpacity,this.v=this.layer.options.speedFactor,this.u=this.layer.options.dropRate,this.m=this.layer.options.dropRateBump,this.g=this.layer.options.colors}p(){this.renderer=new s.Renderer(this.regl);const n=this.canvas.width||1,t=this.canvas.height||1;this.U=n,this.C=t,this.D(),this.P(),this.W(),this.setColorRamp(this.g),this.S=this.regl.framebuffer({color:this.regl.texture({width:n,height:t,wrap:"clamp"}),depth:!0})}P(){const n=this.canvas.width||1,t=this.canvas.height||1,e=new Uint8Array(n*t*4);this.M=this.regl.texture({width:n,height:t,data:e}),this.V=this.regl.texture({width:n,height:t,data:e}),this.R||this.k()}k(){if(t.isString(this.s.image)){const n=new Image;n.src=this.s.image,n.onload=(()=>{this.s.image=n,this.A(),this.layer.fire("windtexture-create-debug")})}else this.A()}A(){this.s.image&&(this.R=this.regl.texture({data:this.s.image,mag:"linear",min:"linear"}))}D(){const n=this.H=Math.ceil(Math.sqrt(this.l));this.F=n*n;const t=new Uint8Array(4*this.F);for(let n=0;n<t.length;n++)t[n]=Math.floor(256*Math.random());if(this.regl){this.j=this.regl.texture({data:t,width:n,height:n}),this.G=this.regl.texture({data:t,width:n,height:n}),this.B=new Float32Array(this.F);for(let n=0;n<this.F;n++)this.B[n]=n}}W(){const n={x:0,y:0,width:()=>this.canvas?this.canvas.width:1,height:()=>this.canvas?this.canvas.height:1};this.drawShader=new s.MeshShader({vert:a,frag:_,uniforms:["extent","u_wind","u_particles","u_color_ramp","u_particles_res","u_wind_min","u_wind_max"],extraCommandProps:{viewport:n},defines:{}}),this.screenShader=new s.MeshShader({vert:p,frag:c,uniforms:["u_screen","u_opacity"],extraCommandProps:{viewport:n},defines:{}}),this.updateSHader=new s.MeshShader({vert:p,frag:l,uniforms:["extent","u_wind","u_particles","u_rand_seed","u_wind_res","u_wind_min","u_wind_max","u_speed_factor","u_drop_rate","u_drop_rate_bump"],extraCommandProps:{viewport:{x:0,y:0,width:()=>this.H,height:()=>this.H},dither:!0},defines:{}}),this.windShader=new s.MeshShader({vert:h,frag:v,uniforms:["u_screen","u_opacity","projViewMatrix",{name:"projViewModelMatrix",type:"function",fn:function(n,t){return o.multiply([],t.projViewMatrix,t.modelMatrix)}}],extraCommandProps:{viewport:n},defines:{}})}_(n,t){const e=["webgl","experimental-webgl"];let i=null;for(let r=0;r<e.length;++r){try{i=n.getContext(e[r],t)}catch(n){}if(i)break}return i}resizeCanvas(){if(this.M&&this.V&&this.O()){const n=this.canvas.width,t=this.canvas.height,e=new Uint8Array(n*t*4);this.M({width:n,height:t,data:e}),this.V({width:n,height:t,data:e}),this.U=n,this.C=t}super.resizeCanvas()}O(){return this.U!=this.canvas.width||this.C!=this.canvas.height}setData(n){this.s=n,this.k()}setParticlesCount(n){this.l=n,this.D()}getParticlesCount(){return this.l}setColorRamp(n){this.T=this.regl.texture({width:16,height:16,data:this.I(n),mag:"linear",min:"linear"})}I(n){const t=document.createElement("canvas"),e=t.getContext("2d");t.width=256,t.height=1;const i=e.createLinearGradient(0,0,256,0);for(const t in n)i.addColorStop(+t,n[t]);return e.fillStyle=i,e.fillRect(0,0,256,1),new Uint8Array(e.getImageData(0,0,256,1).data)}L(){const n=new s.Geometry({a_pos:[0,0,1,0,0,1,0,1,1,0,1,1]},6,0,{primitive:"triangle",positionAttribute:"a_pos",positionSize:2}),t=new s.Mesh(n);return new s.Scene([t])}N(){const n=new s.Geometry({a_index:this.B},this.B.length,0,{primitive:"point",positionAttribute:"a_index",positionSize:1}),t=new s.Mesh(n);return new s.Scene([t])}q(){const n=this.layer.getMap(),t=this.J(),i=u(n,new e([t.xmin,t.ymax])),r=u(n,new e(t.xmin,t.ymin)),o=u(n,new e(t.xmax,t.ymin)),a=u(n,new e(t.xmax,t.ymax)),_=new s.Geometry({a_pos:[r[0],r[1],r[2],o[0],o[1],o[2],i[0],i[1],i[2],i[0],i[1],i[2],o[0],o[1],o[2],a[0],a[1],a[2]],uv:[0,0,1,0,0,1,0,1,1,0,1,1]},6,0,{primitive:"triangle",positionAttribute:"a_pos",positionSize:3}),p=new s.Mesh(_);return new s.Scene([p])}K(){const n=this.layer.getMap();this.S({color:this.V}),this.X();const t=this.L();this.renderer.render(this.screenShader,{u_screen:this.M,u_opacity:this.h},t,this.S);const e=this.q();this.renderer.render(this.windShader,{u_screen:this.V,u_opacity:1,projViewMatrix:n.projViewMatrix},e);const i=this.M;this.M=this.V,this.V=i}X(){const n=this.J(),t=this.N();this.renderer.render(this.drawShader,{extent:[n.xmin,n.xmax,-n.ymax,-n.ymin],u_wind:this.R,u_particles:this.j,u_color_ramp:this.T,u_particles_res:this.H,u_wind_min:[this.s.uMin,this.s.vMin],u_wind_max:[this.s.uMax,this.s.vMax]},t,this.S)}Y(){this.S({color:this.G});const n=this.J(),t=this.L();this.renderer.render(this.updateSHader,{extent:[n.xmin,n.xmax,-n.ymax,-n.ymin],u_wind:this.R,u_particles:this.j,u_rand_seed:Math.random(),u_wind_res:[this.s.width,this.s.height],u_wind_min:[this.s.uMin,this.s.vMin],u_wind_max:[this.s.uMax,this.s.vMax],u_speed_factor:this.v,u_drop_rate:this.u,u_drop_rate_bump:this.m},t,this.S);const e=this.j;this.j=this.G,this.G=e}o(){this.V&&this.M&&this.R&&(this.i(),this.K(),this.Y())}J(){const n=this.layer.getMap().getExtent();return n.xmax<n.xmin&&(n.xmax=n.xmax+360),n}getSpeed(n){if(!this.regl)return;const t=(n.x%180+180)/360*this.s.width;if(n.y<-90||n.y>90)throw new Error("Invalid y for coordinate");const e=(90-n.y)/180*this.s.height,i=this.regl.framebuffer({color:this.R,width:this.s.width,height:this.s.height}),r=this.regl.read({x:t,y:e,width:1,height:1,framebuffer:i});return[r[0]*(this.s.uMax-this.s.uMin)/255+this.s.uMin,r[1]*(this.s.vMax-this.s.vMin)/255+this.s.vMin]}});export{x as WindLayer};"undefined"!=typeof console&&console.log("maptalks.wind v0.1.1, requires maptalks@<2.0.0.");

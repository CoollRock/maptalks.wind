/*!
 * maptalks.wind v0.1.4
 * LICENSE : UNLICENSED
 * (c) 2016-2019 maptalks.org
 */
import{renderer as n,Util as t,Ajax as e,Coordinate as i,Layer as s}from"maptalks";import{createREGL as r,reshader as o,mat4 as a}from"@maptalks/gl";var _="precision mediump float;\n\n\n\nattribute float a_index;\n\n\n\nuniform sampler2D u_particles;\n\nuniform float u_particles_res;\n\n\n\nvarying vec2 v_particle_pos;\n\n\n\nvoid main() {\n\n    vec4 color = texture2D(u_particles, vec2(\n\n        fract(a_index / u_particles_res),\n\n        floor(a_index / u_particles_res) / u_particles_res));\n\n\n\n    // decode current particle position from the pixel's RGBA value\n\n    v_particle_pos = vec2(\n\n        color.r / 255.0 + color.b,\n\n        color.g / 255.0 + color.a);\n\n\n\n    gl_PointSize = 1.0;\n\n    gl_Position = vec4(2.0 * v_particle_pos.x - 1.0, 1.0 - 2.0 * v_particle_pos.y, 0, 1);\n\n}\n\n",l="precision mediump float;\n\n\n\nuniform sampler2D u_wind;\n\nuniform vec2 u_wind_min;\n\nuniform vec2 u_wind_max;\n\nuniform sampler2D u_color_ramp;\n\n\n\nvarying vec2 v_particle_pos;\n\nuniform vec4 extent;\n\n\n\nuniform vec4 full_extent;\n\nuniform float full_width;\n\nuniform float full_height;\n\nuniform float dx;\n\nuniform float dy;\n\n\n\n//重新计算视图区域的纹理采样坐标，将粒子缩放到extent范围内\n\nvec2 computeUV(vec2 v_particle_pos) {\n\n    // float xmin = (extent.x - full_extent.x) / (full_width * dx);\n\n    // float ymin = (extent.z - full_extent.z) / (full_height * dy);\n\n    // float xmax = (extent.y - full_extent.x) / (full_width * dx);\n\n    // float ymax = (extent.w - full_extent.z) / (full_height * dy);\n\n    float xmin = (extent.x - (-180.0)) / (360.0 * 1.0);\n\n    float ymin = (extent.z - (-90.0)) / (180.0 * 1.0);\n\n    float xmax = (extent.y - (-180.0)) / (360.0 * 1.0);\n\n    float ymax = (extent.w - (-90.0)) / (180.0 * 1.0);\n\n    float xWidth = xmax - xmin;\n\n    float yHeight = ymax - ymin;\n\n    vec2 centerUv = vec2(0.5, 0.5);\n\n\n\n    if(v_particle_pos.x < centerUv.x && v_particle_pos.y < centerUv.y) {\n\n        v_particle_pos.x = v_particle_pos.x * xWidth + xmin;\n\n        v_particle_pos.y = v_particle_pos.y * yHeight + ymin;\n\n    } else if(v_particle_pos.x < centerUv.x && v_particle_pos.y > centerUv.y) {\n\n        v_particle_pos.x = v_particle_pos.x * xWidth + xmin;\n\n        v_particle_pos.y = (v_particle_pos.y - 1.0) * yHeight + ymax ;\n\n    } else if(v_particle_pos.x > centerUv.x && v_particle_pos.y < centerUv.y) {\n\n        v_particle_pos.x = (v_particle_pos.x - 1.0) * xWidth + xmax;\n\n        v_particle_pos.y = v_particle_pos.y * yHeight + ymin;\n\n    } else if(v_particle_pos.x > centerUv.x && v_particle_pos.y > centerUv.y) {\n\n        v_particle_pos.x = (v_particle_pos.x - 1.0) * xWidth + xmax;\n\n        v_particle_pos.y = (v_particle_pos.y - 1.0) * yHeight + ymax;\n\n    }\n\n    if (v_particle_pos.x > 1.0) {\n\n        v_particle_pos.x = v_particle_pos.x - 1.0;\n\n    } else if(v_particle_pos.x < 0.0) {\n\n        v_particle_pos.x = v_particle_pos.x + 1.0;\n\n    }\n\n    return v_particle_pos;\n\n}\n\n\n\nvoid main() {\n\n    vec2 particle_pos = computeUV(v_particle_pos);\n\n    if (particle_pos.y < 0.0 || particle_pos.y > 1.0) {\n\n        gl_FragColor = vec4(0.0);\n\n    } else {\n\n        vec2 velocity = mix(u_wind_min, u_wind_max, texture2D(u_wind, particle_pos).rg);\n\n        float speed_t = length(velocity) / length(u_wind_max);\n\n    \n\n        // color ramp is encoded in a 16x16 texture\n\n        vec2 ramp_pos = vec2(\n\n            fract(16.0 * speed_t),\n\n            floor(16.0 * speed_t) / 16.0);\n\n    \n\n        gl_FragColor = texture2D(u_color_ramp, ramp_pos);\n\n    }\n\n}\n\n",h="precision mediump float;\n\n\n\nattribute vec2 a_pos;\n\n\n\nvarying vec2 v_tex_pos;\n\n\n\nvoid main() {\n\n    v_tex_pos = a_pos;\n\n    gl_Position = vec4(1.0 - 2.0 * a_pos, 0, 1);\n\n}\n\n",c="precision mediump float;\n\n\n\nuniform sampler2D u_screen;\n\nuniform float u_opacity;\n\n\n\nvarying vec2 v_tex_pos;\n\n\n\nvoid main() {\n\n    vec4 color = texture2D(u_screen, 1.0 - v_tex_pos);\n\n    // a hack to guarantee opacity fade out even with a value close to 1.0\n\n    gl_FragColor = vec4(floor(255.0 * color * u_opacity) / 255.0);\n\n}\n\n",p="precision highp float;\n\n\n\nuniform sampler2D u_particles;\n\nuniform sampler2D u_wind;\n\nuniform vec2 u_wind_res;\n\nuniform vec2 u_wind_min;\n\nuniform vec2 u_wind_max;\n\nuniform float u_rand_seed;\n\nuniform float u_speed_factor;\n\nuniform float u_drop_rate;\n\nuniform float u_drop_rate_bump;\n\nuniform vec4 full_extent;\n\nuniform float full_width;\n\nuniform float full_height;\n\n\n\nvarying vec2 v_tex_pos;\n\n\n\nuniform vec4 extent;\n\nuniform float dx;\n\nuniform float dy;\n\n\n\n// pseudo-random generator\n\nconst vec3 rand_constants = vec3(12.9898, 78.233, 4375.85453);\n\nfloat rand(const vec2 co) {\n\n    float t = dot(rand_constants.xy, co);\n\n    return fract(sin(t) * (rand_constants.z + t));\n\n}\n\n\n\nvec2 getNewUV(vec2 uv) {\n\n    // float xmin = (extent.x - full_extent.x) / (full_width * dx);\n\n    // float ymin = (extent.z - full_extent.z) / (full_height * dy);\n\n    // float xmax = (extent.y - full_extent.x) / (full_width * dx);\n\n    // float ymax = (extent.w - full_extent.z) / (full_height * dy);\n\n    float xmin = (extent.x - (-180.0)) / (360.0);\n\n    float ymin = (extent.z - (-90.0)) / (180.0);\n\n    float xmax = (extent.y - (-180.0)) / (360.0);\n\n    float ymax = (extent.w - (-90.0)) / (180.0);\n\n    float xWidth = xmax - xmin;\n\n    float yHeight = ymax - ymin;\n\n    vec2 centerUv = vec2(0.5, 0.5);\n\n    vec2 v_particle_pos = uv;\n\n\n\n    if(v_particle_pos.x < centerUv.x && v_particle_pos.y < centerUv.y) {\n\n        v_particle_pos.x = v_particle_pos.x * xWidth + xmin;\n\n        v_particle_pos.y = v_particle_pos.y * yHeight + ymin;\n\n    } else if(v_particle_pos.x < centerUv.x && v_particle_pos.y > centerUv.y) {\n\n        v_particle_pos.x = v_particle_pos.x * xWidth + xmin;\n\n        v_particle_pos.y = (v_particle_pos.y - 1.0) * yHeight + ymax ;\n\n    } else if(v_particle_pos.x > centerUv.x && v_particle_pos.y < centerUv.y) {\n\n        v_particle_pos.x = (v_particle_pos.x -  1.0) * xWidth + xmax;\n\n        v_particle_pos.y = v_particle_pos.y * yHeight + ymin;\n\n    } else if(v_particle_pos.x > centerUv.x && v_particle_pos.y > centerUv.y) {\n\n        v_particle_pos.x = (v_particle_pos.x -  1.0) * xWidth + xmax;\n\n        v_particle_pos.y = (v_particle_pos.y -  1.0) * yHeight + ymax;\n\n    }\n\n    if (v_particle_pos.x > 1.0) {\n\n        v_particle_pos.x = v_particle_pos.x - 1.0;\n\n    } else if(v_particle_pos.x < 0.0) {\n\n        v_particle_pos.x = v_particle_pos.x + 1.0;\n\n    }\n\n    return v_particle_pos;\n\n}\n\n\n\n// wind speed lookup; use manual bilinear filtering based on 4 adjacent pixels for smooth interpolation\n\nvec2 lookup_wind(const vec2 uv) {\n\n    // return texture2D(u_wind, uv).rg; // lower-res hardware filtering\n\n    vec2 px = 1.0 / u_wind_res;\n\n    // vec2 vc = (floor(uv * u_wind_res)) * px;\n\n    // vec2 f = fract(uv * u_wind_res);\n\n    vec2 vc = (floor(uv * u_wind_res)) * px;\n\n    vec2 f = fract(uv * u_wind_res);\n\n    vec2 tl = texture2D(u_wind, vc).rg;\n\n    vec2 tr = texture2D(u_wind, vc + vec2(px.x, 0)).rg;\n\n    vec2 bl = texture2D(u_wind, vc + vec2(0, px.y)).rg;\n\n    vec2 br = texture2D(u_wind, vc + px).rg;\n\n    return mix(mix(tl, tr, f.x), mix(bl, br, f.x), f.y);\n\n}\n\n\n\nvoid main() {\n\n    vec4 color = texture2D(u_particles, v_tex_pos);\n\n    vec2 pos = vec2(\n\n        color.r / 255.0 + color.b,\n\n        color.g / 255.0 + color.a); // decode particle position from pixel RGBA\n\n    vec2 newUV = getNewUV(pos);\n\n    if (newUV.y < 0.0 || newUV.y > 1.0) {\n\n        gl_FragColor = vec4(0.0);\n\n    } else {\n\n        vec2 velocity = mix(u_wind_min, u_wind_max, lookup_wind(newUV));\n\n        float speed_t = length(velocity) / length(u_wind_max);\n\n    \n\n        // take EPSG:4236 distortion into account for calculating where the particle moved\n\n        float distortion = cos(radians(newUV.y));\n\n        vec2 offset = vec2(velocity.x / distortion, -velocity.y) * 0.0001 * u_speed_factor;\n\n    \n\n        // update particle position, wrapping around the date line\n\n        pos = fract(1.0 + pos + offset);\n\n    \n\n        // a random seed to use for the particle drop\n\n        vec2 seed = (pos + v_tex_pos) * u_rand_seed;\n\n    \n\n        // drop rate is a chance a particle will restart at random position, to avoid degeneration\n\n        float drop_rate = u_drop_rate + speed_t * u_drop_rate_bump;\n\n        float drop = step(1.0 - drop_rate, rand(seed));\n\n    \n\n        vec2 random_pos = vec2(\n\n            rand(seed + 1.3),\n\n            rand(seed + 2.1));\n\n        pos = mix(pos, random_pos, drop);\n\n    \n\n        // encode the new particle position back into RGBA\n\n        gl_FragColor = vec4(\n\n            fract(pos * 255.0),\n\n            floor(pos * 255.0) / 255.0);\n\n    }\n\n}\n\n",u="precision mediump float;\n\n\n\nattribute vec3 a_pos;\n\nuniform mat4 projViewModelMatrix;\n\nattribute vec2 uv;\n\nvarying vec2 v_tex_pos;\n\n\n\nvoid main() {\n\n    v_tex_pos = uv;\n\n    gl_Position = projViewModelMatrix * vec4(a_pos, 1.0);\n\n}\n\n",d="precision mediump float;\n\nuniform sampler2D u_screen;\n\nuniform float u_opacity;\n\n\n\nvarying vec2 v_tex_pos;\n\n\n\nvoid main() {\n\n    vec4 color = texture2D(u_screen, v_tex_pos);\n\n    // a hack to guarantee opacity fade out even with a value close to 1.0\n\n    gl_FragColor = vec4(floor(255.0 * color * u_opacity) / 255.0);\n\n}\n\n";function x(n,t,e=0){if(!n)return null;const i=n.coordinateToPoint(t,n.getGLZoom());return[i.x,i.y,e]}const v={renderer:"gl",count:65536,fadeOpacity:.996,speedFactor:.25,dropRate:.003,dropRateBump:.01,colors:{0:"#3288bd",.1:"#66c2a5",.2:"#abdda4",.3:"#e6f598",.4:"#fee08b",.5:"#fdae61",.6:"#f46d43",1:"#d53e4f"}};class f extends s{constructor(n,t){super(n,t),this.options.data&&this.setWind(t.data)}setWind(n){this.t("setData",n)}setParticlesCount(n){this.t("setParticlesCount",n)}getParticlesCount(){return this.t("getParticlesCount")}setRampColors(n){this.t("setColorRamp",n)}getWindSpeed(n){return this.t("getSpeed",n)}t(n,t){const e=this.getRenderer();if(e)return e[n](t);this.on("renderercreate",e=>e.renderer[n](t))}}f.mergeOptions(v),f.registerJSONType("WindLayer"),f.registerRenderer("gl",class extends n.CanvasRenderer{constructor(n){super(n),this.i(),this.s={}}draw(){this.prepareCanvas(),this.o()}drawOnInteracting(){this.o()}needToRedraw(){return!0}hitDetect(){return!1}createContext(){if(this.canvas.gl&&this.canvas.gl.wrap)this.gl=this.canvas.gl.wrap();else{const n=this.layer.options.glOptions||{alpha:!0,depth:!0,stencil:!0};this.glOptions=n,this.gl=this.gl||this._(this.canvas,n)}this.regl=r({gl:this.gl,extensions:["OES_element_index_uint","OES_standard_derivatives"],optionalExtensions:this.layer.options.glExtensions||[]}),this.l()}clearCanvas(){this.canvas&&(this.regl.clear({color:[0,0,0,0],depth:1,stencil:0}),super.clearCanvas())}i(){this.h=this.layer.options.count,this.p=this.layer.options.fadeOpacity,this.u=this.layer.options.speedFactor,this.v=this.layer.options.dropRate,this.m=this.layer.options.dropRateBump,this.g=this.layer.options.colors}l(){this.renderer=new o.Renderer(this.regl);const n=this.canvas.width||1,t=this.canvas.height||1;this.U=n,this.C=t,this.M(),this.D(),this.P(),this.setColorRamp(this.g),this.S=this.regl.framebuffer({color:this.regl.texture({width:n,height:t,wrap:"clamp"}),depth:!0})}D(){const n=this.canvas.width||1,t=this.canvas.height||1,e=new Uint8Array(n*t*4);this.W=this.regl.texture({width:n,height:t,data:e}),this.V=this.regl.texture({width:n,height:t,data:e}),this.R||this.k()}k(){if(t.isString(this.s)&&this.s.indexOf(".json")>-1)e.get(this.s,(n,t)=>{if(n)throw new Error(n);this.s=this.A(JSON.parse(t)),this.F()});else if(this.isGFSObject())this.s=this.A(this.s),this.F();else if(t.isString(this.s.image)){const n=new Image;n.src=this.s.image,n.onload=(()=>{this.s.image=n,this.F(),this.layer.fire("windtexture-create-debug")})}else this.F()}F(){this.s&&(this.R=this.regl.texture({width:this.s.width,height:this.s.height,data:this.s.image,mag:"linear",min:"linear"}))}isGFSObject(){return!(!this.s[0]||!this.s[0].header||"object"!=typeof this.s[0].header)}M(){const n=this.H=Math.ceil(Math.sqrt(this.h));this.j=n*n;const t=new Uint8Array(4*this.j);for(let n=0;n<t.length;n++)t[n]=Math.floor(256*Math.random());if(this.regl){this.G=this.regl.texture({data:t,width:n,height:n}),this.O=this.regl.texture({data:t,width:n,height:n}),this.B=new Float32Array(this.j);for(let n=0;n<this.j;n++)this.B[n]=n}}P(){const n={x:0,y:0,width:()=>this.canvas?this.canvas.width:1,height:()=>this.canvas?this.canvas.height:1};this.drawShader=new o.MeshShader({vert:_,frag:l,uniforms:["extent","u_wind","u_particles","u_color_ramp","u_particles_res","u_wind_min","u_wind_max","full_width","full_height","full_extent","dx","dy"],extraCommandProps:{viewport:n},defines:{}}),this.screenShader=new o.MeshShader({vert:h,frag:c,uniforms:["u_screen","u_opacity"],extraCommandProps:{viewport:n},defines:{}}),this.updateSHader=new o.MeshShader({vert:h,frag:p,uniforms:["extent","u_wind","u_particles","u_rand_seed","u_wind_res","u_wind_min","u_wind_max","u_speed_factor","u_drop_rate","u_drop_rate_bump","full_width","full_height","full_extent","dx","dy"],extraCommandProps:{viewport:{x:0,y:0,width:()=>this.H,height:()=>this.H},dither:!0},defines:{}}),this.windShader=new o.MeshShader({vert:u,frag:d,uniforms:["u_screen","u_opacity","projViewMatrix",{name:"projViewModelMatrix",type:"function",fn:function(n,t){return a.multiply([],t.projViewMatrix,t.modelMatrix)}}],extraCommandProps:{viewport:n},defines:{}})}A(n){const t=n[0],e=n[1],i=Math.min.apply(null,t.data),s=Math.max.apply(null,t.data),r=Math.min.apply(null,e.data),o=Math.max.apply(null,e.data),a=[];for(let n=0;n<t.data.length;n++){const _=Math.floor(255*(t.data[n]-i)/(s-i));a.push(_);const l=Math.floor(255*(e.data[n]-r)/(o-r));a.push(l),a.push(0),a.push(255)}return{width:t.header.nx,height:t.header.ny,uMin:i,uMax:s,vMin:r,vMax:o,image:a,full_extent:[t.header.lo1,t.header.lo2,t.header.la1,t.header.la2],dx:t.header.dx,dy:t.header.dy}}_(n,t){const e=["webgl","experimental-webgl"];let i=null;for(let s=0;s<e.length;++s){try{i=n.getContext(e[s],t)}catch(n){}if(i)break}return i}resizeCanvas(){if(this.W&&this.V&&this.T()){const n=this.canvas.width,t=this.canvas.height,e=new Uint8Array(n*t*4);this.W({width:n,height:t,data:e}),this.V({width:n,height:t,data:e}),this.U=n,this.C=t}super.resizeCanvas()}T(){return this.U!=this.canvas.width||this.C!=this.canvas.height}setData(n){this.s=n,this.regl&&this.k()}setParticlesCount(n){this.h=n,this.M()}getParticlesCount(){return this.h}setColorRamp(n){this.I=this.regl.texture({width:16,height:16,data:this.N(n),mag:"linear",min:"linear"})}N(n){const t=document.createElement("canvas"),e=t.getContext("2d");t.width=256,t.height=1;const i=e.createLinearGradient(0,0,256,0);for(const t in n)i.addColorStop(+t,n[t]);return e.fillStyle=i,e.fillRect(0,0,256,1),new Uint8Array(e.getImageData(0,0,256,1).data)}L(){const n=new o.Geometry({a_pos:[0,0,1,0,0,1,0,1,1,0,1,1]},6,0,{primitive:"triangle",positionAttribute:"a_pos",positionSize:2}),t=new o.Mesh(n);return new o.Scene([t])}q(){const n=new o.Geometry({a_index:this.B},this.B.length,0,{primitive:"point",positionAttribute:"a_index",positionSize:1}),t=new o.Mesh(n);return new o.Scene([t])}J(){const n=this.layer.getMap(),t=this.K(),e=x(n,new i([t.xmin,t.ymax])),s=x(n,new i(t.xmin,t.ymin)),r=x(n,new i(t.xmax,t.ymin)),a=x(n,new i(t.xmax,t.ymax)),_=new o.Geometry({a_pos:[s[0],s[1],s[2],r[0],r[1],r[2],e[0],e[1],e[2],e[0],e[1],e[2],r[0],r[1],r[2],a[0],a[1],a[2]],uv:[0,0,1,0,0,1,0,1,1,0,1,1]},6,0,{primitive:"triangle",positionAttribute:"a_pos",positionSize:3}),l=new o.Mesh(_);return new o.Scene([l])}X(){const n=this.layer.getMap();this.S({color:this.V}),this.Y();const t=this.L();this.renderer.render(this.screenShader,{u_screen:this.W,u_opacity:this.p},t,this.S);const e=this.J();this.renderer.render(this.windShader,{u_screen:this.V,u_opacity:1,projViewMatrix:n.projViewMatrix},e);const i=this.W;this.W=this.V,this.V=i}Y(){const n=this.K(),t=this.q();this.renderer.render(this.drawShader,{extent:[n.xmin,n.xmax,-n.ymax,-n.ymin],u_wind:this.R,u_particles:this.G,u_color_ramp:this.I,u_particles_res:this.H,u_wind_min:[this.s.uMin,this.s.vMin],u_wind_max:[this.s.uMax,this.s.vMax],full_width:this.s.width,full_height:this.s.height,full_extent:this.s.full_extent,dx:this.s.dx,dy:this.s.dy},t,this.S)}Z(){this.S({color:this.O});const n=this.K(),t=this.L();this.renderer.render(this.updateSHader,{extent:[n.xmin,n.xmax,-n.ymax,-n.ymin],u_wind:this.R,u_particles:this.G,u_rand_seed:Math.random(),u_wind_res:[this.s.width,this.s.height],u_wind_min:[this.s.uMin,this.s.vMin],u_wind_max:[this.s.uMax,this.s.vMax],u_speed_factor:this.u,u_drop_rate:this.v,u_drop_rate_bump:this.m,full_width:this.s.width,full_height:this.s.height,full_extent:this.s.full_extent,dx:this.s.dx,dy:this.s.dy},t,this.S);const e=this.G;this.G=this.O,this.O=e}o(){this.V&&this.W&&this.R&&(this.i(),this.X(),this.Z())}K(){const n=this.layer.getMap().getExtent();return n.xmax<n.xmin&&(n.xmax=n.xmax+360),n.xmin=n.xmin<this.s.full_extent[0]?this.s.full_extent[0]:n.xmin,n.xmax=n.xmax>this.s.full_extent[1]?this.s.full_extent[1]:n.xmax,n.ymin=n.ymin<this.s.full_extent[2]?this.s.full_extent[2]:n.ymin,n.ymax=n.ymax>this.s.full_extent[3]?this.s.full_extent[3]:n.ymax,n}getSpeed(n){if(!this.regl||!this.s||!this.s.width)return;const t=(n.x%180+180)/360*this.s.width;if(n.y<-90||n.y>90)throw new Error("Invalid y for coordinate");const e=(90-n.y)/180*this.s.height,i=this.regl.framebuffer({color:this.R,width:this.s.width,height:this.s.height}),s=this.regl.read({x:t,y:e,width:1,height:1,framebuffer:i});return[s[0]*(this.s.uMax-this.s.uMin)/255+this.s.uMin,s[1]*(this.s.vMax-this.s.vMin)/255+this.s.vMin]}});export{f as WindLayer};"undefined"!=typeof console&&console.log("maptalks.wind v0.1.4, requires maptalks@<2.0.0.");
